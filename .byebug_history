exit
Smash::CloudPowers.included_modules
Smash::CloudPowers
Pipe
Queue
CloudPowers.public_methods(false)
CloudPowers.public_methods
CloudPowers.included_modules
CloudPowers.methods.sort
CloudPowers
self.methods.sort
self.modules
c
exit
Smash.const_get(to_pascal(task)).new
Smash.const_get(to_pascal(task))
to_pascal(task)
c
exit
n
var.to_s[/\.{1}[a-z]+$/]
l
l-
u = basename(Pathname(var))
u
v
var.to_s.gsub(/\.\w+$/, '').gsub(/\W/, '_').downcase + (file_ext || '')
var.to_s.gsub(/\.\w+$/, '').gsub(/\W/, '_').downcase + file_ext
file_ext = var.to_s[/\.{1}[a-z]+$/]
var.to_s[/\.{1}[a-z]+$/]
var.to_s
eval 'var'
var
s
name
to_snake(name)
s
task
n
body
n
s
c
n
s
c
n
exit
FileUtils::touch(task_path('testinz.rb'))
FileUtils::mkdir_p task_path
task_path
FileUtils::touch(task_path('testinz.rb'))
task_path('testinz.rb')
exit
Pathname(__FILE__).parent.dirname + "tasks/#{to_snake(file)}"
file.empty?
s
exit
Pathname(__FILE__).dirname.parent + 'tasks' + ''
to_snake(t_p)
t_p
file.empty? ? t_p : Pathname(to_snake(t_p))
file
t_p
n
s
c
b = ok['.rb']
ok
ok['.rb']
ok = 'bla.rb'
s3
s3.stub_responses(:list_buckets, [])
c
exit
@uuu
n
exit
File.open '/Users/adam/code/cloud_powers/lib/tasks/testinz.rb'
task_path 'testinz'
task_path
task_path_name
exit
ext
exit
FileUtils.ls(task_path '')
FileUtils.ls(task_path)
task_path('testinz') + '.rb'
c
exit
puts ENV.keys.sort
ENV
key
s
region
s
s3.list_objects(bucket: bucket).contents
bucket = 'jobRequests'
bucket
n
task_path(file).exist?
n
s
n
s
c
s
n
task
n
msg.body
msg
s
Smash::Testinz.new
Smash::Testinz
c
name
s
c
b = OpenStruct.new(name: 'yo', body: {})
require 'ostruct'
k = Struct.new(name: 'ok')
JSON.parse(msg.body)
s
exit
exception
n
{ body: {} }.to_json
c
exit
self.class
build
Delegator.build
c
exit
Delegator.build
exit
build
l-
Smash::CloudPowers::Delegator.methods.sort
puts Delegator.class
puts Delegator.methods.sort
Delegator.class
Delegator
c
exit
@instance_url =~ URI::regexp
@instance_url
exit
get_instance_url
instance_url
@instance_url
c
n
c
expect(now).to be_less_than(boot_time)
boot_time
task_name
@boot_time
@task_name
n
s
exit
l
l-
ec2.describe_instances(instance_ids: [ids].flatten).reservations[0].instances[0].tags.select { |t| t.value if t.key == 'taskType' }
env '*'
env *
env
ec2.describe_instances(instance_ids: [ids].flatten).reservations[0].instances[0].tags.select { |t| t.value if t.key == 'taskType' }
ec2.stub_responses
ec2.stub_response
ec2.describe_instances(instance_ids: [ids].flatten)
ids
s
@task_name
s
n
@boot_time
n
c
exit
e
format_error_message e
e
s
format_error_message e
format_error_message
n
ec2.describe_instances(dry_run: env('testing'), instance_ids:[@instance_id]).reservations[0].instances[0].launch_time.to_i
@instance_id
n
s
n
exit
n
value
key
n
key
n
s
block_given?
key
n
s
keys
n
key
n
env('TESTING')
s
exit
get_awareness!
methods.sort
get!
@instance_id
@boot_time
n
s
exit
region
boot_time
exit
f = File.new('.test.env')
`pwd`
pwd
Dotenv.load('.test.env')
Dotenv.load(.test.env)
require 'dotenv'
c
exit
ENV[to_snake(key).upcase]
require 'dotenv'
s
n
s
l-
l
puts ENV.keys.sort
ENV['TESTING']
ENV['testing']
region
n
s
c
exit
q = Boogs.new
exit
build
self.extend Smash::Delegator
exit
build
self.extend Smash::Delegator
exit
self
